!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BACKLOG	client_handle.cpp	/^static int BACKLOG = 100000;$/;"	v	file:
BOOTING	pool.h	/^enum Gthread_pool_worker_state {BUSY, READY, BOOTING};$/;"	e	enum:Gthread_pool_worker_state
BUSY	pool.h	/^enum Gthread_pool_worker_state {BUSY, READY, BOOTING};$/;"	e	enum:Gthread_pool_worker_state
CC	Makefile	/^CC=g++$/;"	m
CFLAGS	Makefile	/^CFLAGS = -Wall$/;"	m
CGIRoot	config.h	/^    char CGIRoot[128];$/;"	m	struct:server_conf
ConfGetLine	para_init.cpp	/^static int ConfGetLine(int fd,char *buffer,int len){$/;"	f	file:
ConfigFile	config.h	/^    char ConfigFile[128];$/;"	m	struct:server_conf
DATA_IN	config.h	31;"	d
DATA_OUT	config.h	32;"	d
DEBUG	config.h	22;"	d
DefaultFile	config.h	/^    char DefaultFile[128];$/;"	m	struct:server_conf
Displayconf	para_init.cpp	/^int Displayconf(){$/;"	f
DocumentRoot	config.h	/^    char DocumentRoot[128];$/;"	m	struct:server_conf
FAILURE	config.h	28;"	d
Getpara_cmd	para_init.cpp	/^int Getpara_cmd(int argc,char *argv[]){$/;"	f
Getpara_file	para_init.cpp	/^int Getpara_file(char *file){$/;"	f
Gthread_pool	pool.h	/^struct Gthread_pool{$/;"	s
Gthread_pool_flag	pool.h	/^enum Gthread_pool_flag {RUN, SHUTDOWN}; $/;"	g
Gthread_pool_init	workers_manage.cpp	/^int Gthread_pool_init(struct Gthread_pool *pool, int max_tasks, int max_workers, int min_workers){$/;"	f
Gthread_pool_task	pool.h	/^struct Gthread_pool_task{$/;"	s
Gthread_pool_worker	pool.h	/^struct Gthread_pool_worker{$/;"	s
Gthread_pool_worker_routline_args	pool.h	/^struct Gthread_pool_worker_routline_args{$/;"	s
Gthread_pool_worker_state	pool.h	/^enum Gthread_pool_worker_state {BUSY, READY, BOOTING};$/;"	g
HTTP_POOL	httpd.h	2;"	d
HTTP_POOL	pool.h	2;"	d
INIT_LIST_HEAD	Glist.h	/^static inline void INIT_LIST_HEAD(struct list_head * name)$/;"	f
IO_lock	pool.h	/^	pthread_mutex_t IO_lock;$/;"	m	struct:Gthread_pool
ISspace	httpd.h	17;"	d
InitWorkerNum	config.h	/^    int InitWorkerNum;$/;"	m	struct:server_conf
LIBS	Makefile	/^LIBS = -lpthread $/;"	m
LIFE_TIME	timer.h	12;"	d
LINELEN	para_init.cpp	59;"	d	file:
LIST_HEAD	Glist.h	29;"	d
LIST_HEAD_INIT	Glist.h	27;"	d
ListenPort	config.h	/^    int ListenPort;$/;"	m	struct:server_conf
MAXEVENTS	client_handle.cpp	22;"	d	file:
MAXEVENTS	httpd.h	28;"	d
MAX_FD	timer.h	10;"	d
METHOD_LEN	client_handle.cpp	18;"	d	file:
METHOD_LEN	httpd.h	24;"	d
MaxClient	config.h	/^    int MaxClient;   $/;"	m	struct:server_conf
MaxWorkerNum	config.h	/^    int MaxWorkerNum;$/;"	m	struct:server_conf
OBJS	Makefile	/^OBJS =main.o para_init.o workers_manage.o server.o timer.o client_handle.o epoll_event_handle.o$/;"	m
PATH_LEN	client_handle.cpp	19;"	d	file:
PATH_LEN	httpd.h	25;"	d
POOL_GATE	workers_manage.cpp	/^static const float POOL_GATE = 0.2;$/;"	v	file:
READY	pool.h	/^enum Gthread_pool_worker_state {BUSY, READY, BOOTING};$/;"	e	enum:Gthread_pool_worker_state
RM	Makefile	/^RM =rm -f$/;"	m
RUN	pool.h	/^enum Gthread_pool_flag {RUN, SHUTDOWN}; $/;"	e	enum:Gthread_pool_flag
SERVER_STRING	httpd.h	19;"	d
SHTTPD_H	config.h	2;"	d
SHUTDOWN	pool.h	/^enum Gthread_pool_flag {RUN, SHUTDOWN}; $/;"	e	enum:Gthread_pool_flag
SLEEP_TIME	config.h	24;"	d
SLOT_TIME	timer.h	13;"	d
STDERR	httpd.h	22;"	d
STDIN	httpd.h	20;"	d
STDOUT	httpd.h	21;"	d
SUCCESS	config.h	27;"	d
TARGET	Makefile	/^TARGET = ts_http_server$/;"	m
TimeOut	config.h	/^    int TimeOut;$/;"	m	struct:server_conf
URL_LEN	client_handle.cpp	20;"	d	file:
URL_LEN	httpd.h	26;"	d
VERSION_LEN	client_handle.cpp	21;"	d	file:
VERSION_LEN	httpd.h	27;"	d
_MY_TIMER	timer.h	2;"	d
_SERVER	server.h	2;"	d
__LIST_H	Glist.h	2;"	d
__list_add	Glist.h	/^static inline void __list_add(struct list_head * new_node, struct list_head *prev, struct list_head *next)$/;"	f
__list_del	Glist.h	/^static inline void __list_del(struct list_head *prev, struct list_head *next)$/;"	f
__list_splice	Glist.h	/^static inline void __list_splice(struct list_head *list, struct list_head *head)$/;"	f
accept_request	httpd.c	/^void *accept_request(void *arg)$/;"	f
add_event	epoll_event_handle.c	/^void add_event(int epoll_fd, int fd, int event_type)$/;"	f
add_job	workers_manage.cpp	/^int add_job(struct Gthread_pool *pool,void *(*job)(void *arg),void *arg){$/;"	f
add_task	workers_manage.cpp	/^int add_task(struct Gthread_pool_task *task,struct Gthread_pool *pool,void*(*proccess)(void *arg),void *arg){$/;"	f
add_worker	workers_manage.cpp	/^int add_worker(struct Gthread_pool_worker *new_worker,struct Gthread_pool *pool){$/;"	f
arg	pool.h	/^	void * arg;$/;"	m	struct:Gthread_pool_task
bad_request	httpd.c	/^void bad_request(int client)$/;"	f
boot_cond	pool.h	/^	pthread_cond_t boot_cond;$/;"	m	struct:Gthread_pool_worker
boot_lock	pool.h	/^	pthread_mutex_t boot_lock;$/;"	m	struct:Gthread_pool_worker
callback_func	timer.h	/^    void (*callback_func)(void * arg);$/;"	m	struct:timer
cannot_execute	client_handle.cpp	/^void cannot_execute(int client)$/;"	f
cannot_execute	httpd.c	/^void cannot_execute(int client)$/;"	f
cat	client_handle.cpp	/^void cat(int client, FILE *resource)$/;"	f
cat	httpd.c	/^void cat(int client, FILE *resource)$/;"	f
client_service	client_handle.cpp	/^void * client_service(void * arg) $/;"	f
close_client	client_handle.cpp	/^void close_client(int client_fd)$/;"	f
close_client	httpd.c	/^void close_client(int client_fd){$/;"	f
del_event	epoll_event_handle.c	/^void del_event(int epoll_fd, int fd, int event_type)$/;"	f
del_worker_from_pool	workers_manage.cpp	/^int del_worker_from_pool(struct Gthread_pool_worker *del_worker, struct Gthread_pool *pool){$/;"	f
delay	workers_manage.cpp	/^static struct timeval delay = {0, SLEEP_TIME}; $/;"	v	typeref:struct:timeval	file:
distribute_task	workers_manage.cpp	/^void *distribute_task(void * arg){$/;"	f
doGetMethod	client_handle.cpp	/^void doGetMethod(int client_fd, char * url, char * version)$/;"	f
doGetMethod	httpd.c	/^void doGetMethod(int client_fd, char * url, char * version)$/;"	f
error_die	client_handle.cpp	/^static void error_die(const char *sc)$/;"	f	file:
error_die	httpd.c	/^void error_die(const char *sc)$/;"	f
execute_cgi	client_handle.cpp	/^void execute_cgi(int client, const char *path, const char *method, const char *query_string)$/;"	f
execute_cgi	httpd.c	/^void execute_cgi(int client, const char *path,$/;"	f
fd	timer.h	/^    int fd;$/;"	m	struct:timer
file_serve	client_handle.cpp	/^void file_serve(int client_fd, char * filename)$/;"	f
flag	pool.h	/^	enum Gthread_pool_flag flag;\/\/the state of the Gthread pool$/;"	m	struct:Gthread_pool	typeref:enum:Gthread_pool::Gthread_pool_flag
get_line	client_handle.cpp	/^int get_line(int sock, char *buf, int size)$/;"	f
get_line	httpd.c	/^int get_line(int sock, char *buf, int size)$/;"	f
get_pool_now_using	workers_manage.cpp	/^float get_pool_now_using(struct Gthread_pool *pool){$/;"	f
headers	client_handle.cpp	/^void headers(int client)$/;"	f
headers	httpd.c	/^void headers(int client, const char *filename)$/;"	f
id	pool.h	/^	pthread_t id;$/;"	m	struct:Gthread_pool_worker
info_lock	pool.h	/^	pthread_mutex_t info_lock;$/;"	m	struct:Gthread_pool
link_node	pool.h	/^	struct list_head link_node;$/;"	m	struct:Gthread_pool_task	typeref:struct:Gthread_pool_task::list_head
link_node	pool.h	/^	struct list_head link_node;$/;"	m	struct:Gthread_pool_worker	typeref:struct:Gthread_pool_worker::list_head
list_add	Glist.h	/^static inline void list_add(struct list_head * new_node, struct list_head *head)$/;"	f
list_add_tail	Glist.h	/^static inline void list_add_tail(struct list_head *new_node, struct list_head *head)$/;"	f
list_del	Glist.h	/^static inline void list_del(struct list_head *entry)$/;"	f
list_del_init	Glist.h	/^static inline void list_del_init(struct list_head *entry)$/;"	f
list_empty	Glist.h	/^static inline int list_empty(struct list_head *head)$/;"	f
list_entry	Glist.h	193;"	d
list_for_each	Glist.h	201;"	d
list_for_each_entry	Glist.h	229;"	d
list_for_each_entry_safe	Glist.h	241;"	d
list_for_each_prev	Glist.h	209;"	d
list_for_each_safe	Glist.h	219;"	d
list_head	Glist.h	/^struct list_head {$/;"	s
list_move	Glist.h	/^static inline void list_move(struct list_head *list, struct list_head *head)$/;"	f
list_move_tail	Glist.h	/^static inline void list_move_tail(struct list_head *list,$/;"	f
list_splice	Glist.h	/^static inline void list_splice(struct list_head *list, struct list_head *head)$/;"	f
list_splice_init	Glist.h	/^static inline void list_splice_init(struct list_head *list,$/;"	f
long_cmd	para_init.cpp	/^static struct option long_cmd []={$/;"	v	typeref:struct:option	file:
main	main.cpp	/^int main(int argc,char *argv[])$/;"	f
manage_worker	pool.h	/^	pthread_t manage_worker;$/;"	m	struct:Gthread_pool
max_tasks	pool.h	/^	int max_tasks;$/;"	m	struct:Gthread_pool
max_workers	pool.h	/^	int max_workers;$/;"	m	struct:Gthread_pool
min_workers	pool.h	/^	int min_workers;$/;"	m	struct:Gthread_pool
mutex_data	pool.h	/^	struct mutex_pool_data mutex_data;$/;"	m	struct:Gthread_pool	typeref:struct:Gthread_pool::mutex_pool_data
mutex_pool_data	pool.h	/^struct mutex_pool_data{$/;"	s
next	Glist.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
node	timer.h	/^    list_head node; $/;"	m	struct:timer
not_found	client_handle.cpp	/^void not_found(int client)$/;"	f
not_found	httpd.c	/^void not_found(int client)$/;"	f
over_time	timer.h	/^    time_t over_time;$/;"	m	struct:timer
over_time_handle	timer.cpp	/^void over_time_handle(void *fd){$/;"	f
pipefd	client_handle.cpp	/^static int pipefd[2];$/;"	v	file:
pool	client_handle.cpp	/^static struct Gthread_pool pool;$/;"	v	typeref:struct:Gthread_pool	file:
pool	pool.h	/^	struct Gthread_pool * pool;$/;"	m	struct:Gthread_pool_worker_routline_args	typeref:struct:Gthread_pool_worker_routline_args::Gthread_pool
prev	Glist.h	/^	struct list_head *next, *prev;$/;"	m	struct:list_head	typeref:struct:list_head::
proccess	pool.h	/^	void * (*proccess)(void * arg); $/;"	m	struct:Gthread_pool_task
request_handle	client_handle.cpp	/^void request_handle(struct Gthread_pool * pool)$/;"	f
routline_args	pool.h	/^	struct Gthread_pool_worker_routline_args routline_args;$/;"	m	struct:Gthread_pool_worker	typeref:struct:Gthread_pool_worker::Gthread_pool_worker_routline_args
search_idle_worker	workers_manage.cpp	/^struct Gthread_pool_worker * search_idle_worker(Gthread_pool *pool){$/;"	f
serve_file	httpd.c	/^void serve_file(int client, const char *filename)$/;"	f
server_conf	config.h	/^struct server_conf{$/;"	s
server_config	client_handle.cpp	/^static server_conf server_config;$/;"	v	file:
server_init	server.cpp	/^bool server_init(struct Gthread_pool *pool){$/;"	f
server_para	para_init.cpp	/^struct server_conf server_para={$/;"	v	typeref:struct:server_conf
setNoBlock	client_handle.cpp	/^int setNoBlock(int fd)$/;"	f
short_cmd	para_init.cpp	/^static char * short_cmd ="c:d:f:o:l:m:t:i:w:h";$/;"	v	file:
sig_alarm_handle	client_handle.cpp	/^void sig_alarm_handle(int sig)$/;"	f
sig_int_handle	client_handle.cpp	/^void sig_int_handle(int sig)$/;"	f
sig_usr1_handler	workers_manage.cpp	/^void sig_usr1_handler(int signum)$/;"	f
startup	httpd.c	/^int startup(u_short *port)$/;"	f
state	pool.h	/^	enum Gthread_pool_worker_state state;$/;"	m	struct:Gthread_pool_worker	typeref:enum:Gthread_pool_worker::Gthread_pool_worker_state
surplus_task_num	pool.h	/^	sem_t surplus_task_num;\/\/the sem > 0, means there are some tasks to be processed$/;"	m	struct:Gthread_pool
task_distribute_worker	pool.h	/^	pthread_t task_distribute_worker;$/;"	m	struct:Gthread_pool
task_list	pool.h	/^	struct list_head task_list;$/;"	m	struct:Gthread_pool	typeref:struct:Gthread_pool::list_head
task_num	pool.h	/^	int task_num;$/;"	m	struct:mutex_pool_data
this_worker	pool.h	/^    struct Gthread_pool_worker * this_worker;$/;"	m	struct:Gthread_pool_worker_routline_args	typeref:struct:Gthread_pool_worker_routline_args::Gthread_pool_worker
tick_handle	timer.cpp	/^void tick_handle(struct list_head *head){$/;"	f
timer	timer.h	/^typedef struct timer{$/;"	s
timer_add	timer.cpp	/^void timer_add(timer_type *new_timer,struct list_head *head){$/;"	f
timer_cmp	timer.cpp	/^bool timer_cmp(timer_type *timer_l,timer_type *timer_r){$/;"	f
timer_del	timer.cpp	/^void timer_del(timer_type *timer_del,struct list_head *head){$/;"	f
timer_list	client_handle.cpp	/^static list_head timer_list;$/;"	v	file:
timer_lock	timer.cpp	/^pthread_mutex_t timer_lock;$/;"	v
timer_type	timer.h	/^} timer_type;$/;"	t	typeref:struct:timer
timers	timer.cpp	/^timer_type *timers[MAX_FD];$/;"	v
unimplemented	client_handle.cpp	/^void unimplemented(int client)$/;"	f
unimplemented	httpd.c	/^void unimplemented(int client)$/;"	f
worker_cond	pool.h	/^	pthread_cond_t worker_cond;$/;"	m	struct:Gthread_pool_worker
worker_lock	pool.h	/^	pthread_mutex_t worker_lock;$/;"	m	struct:Gthread_pool_worker
worker_manage	workers_manage.cpp	/^void *worker_manage(void *arg){$/;"	f
worker_num	pool.h	/^	int worker_num;$/;"	m	struct:mutex_pool_data
worker_routline	workers_manage.cpp	/^void *worker_routline(void *arg){$/;"	f
worker_task	pool.h	/^	void * (*worker_task)(void * );$/;"	m	struct:Gthread_pool_worker
worker_task_arg	pool.h	/^	void * worker_task_arg;$/;"	m	struct:Gthread_pool_worker
workers	pool.h	/^	struct list_head workers;$/;"	m	struct:Gthread_pool	typeref:struct:Gthread_pool::list_head
